---
title: "Project Description - Rock-paper-scissors-lizard-Spock"
---
<ref: copy and edit from the mini project of cousera courses: An Introduction to Interactive Programming in Python by Rice University>

Rock-paper-scissors is a hand game that is played by two people. The players count to three in unison and simultaneously "throw" one of three hand signals that correspond to rock, paper or scissors. The winner is determined by the rules:

    Rock smashes scissors
	Scissors cuts paper
	Paper covers rock

Rock-paper-scissors is a surprisingly popular game that many people play seriously (look to Wikipedia for details: <http://en.wikipedia.org/wiki/Rock-paper-scissors>). Due to the fact that a tie happens around 1/3 of the time, several variants of Rock-Paper-Scissors exist that include more choices to make ties less likely.

Rock-paper-scissors-lizard-Spock (RPSLS) is a variant of Rock-paper-scissors that allows five choices. Each choice wins against two other choices, loses against two other choices and ties against itself. Much of RPSLS's popularity is that it has been featured in 3 episodes of the TV series "The Big Bang Theory". The Wikipedia entry for RPSLS gives the complete description of the details of the game: <http://en.wikipedia.org/wiki/Rock-paper-scissors-lizard-Spock>

    New members: lizard and Spock
    Relationship:
    lizard poisons Spock, eats paper
    lizard is crushed by rock, is decapitated by scissors
    Spock vaporizes rock, smashes scissors
    Spock is poisoned by lizard, is disproved by paper

In our mini-project, we will build a R function `rpsls(name)` that takes as input the string `name`, which is one of `"rock"`, `"paper"`, `"scissors"`, `"lizard"`, or `"Spock"`. The function then simulates playing a round of Rock-paper-scissors-lizard-Spock by generating its own random choice from these alternatives and then determining the winner using a simple rule that we will next describe.

While Rock-paper-scissor-lizard-Spock has a set of ten rules that logically determine who wins a round of RPSLS, coding up these rules would require a large number (5x5=25) of `if`/`else if`/`else` clauses in your mini-project code. A simpler method for determining the winner is to assign each of the five choices a number: 

    0 - rock
	1 - Spock
	2 - paper
	3 - lizard
	4 - scissors

In this expanded list, each choice wins against the preceding two choices and loses against the following two choices.

**Mini-project development process**

1. Build a helper function `name_to_number(name)` that converts the string name into a number between 0 and 4 as described above. This function should use a sequence of `if`/`else if`/`else` clauses. You can use conditions of the form `name == "paper"`, etc. to distinguish the cases. To make debugging your code easier, we suggest including a final `else` clause that catches cases when name does not match any of the five correct input strings and prints an appropriate error message. You can test your implementation of `name_to_number()` using this name_to_number testing template. 

2. Next, you should build a second helper function `number_to_name(number)` that converts a number in the range 0 to 4 into its corresponding name as a string. Again, we suggest including a final `else` clause that catches cases when number is not in the correct range. You can test your implementation of `number_to_name()` using this number_to_name testing template.

3. Implement the first part of the main function `rpsls(player_choice)`. Print out a blank line (to separate consecutive games) followed by a line with an appropriate message describing the player's choice. Then compute the number `player_number` between 0 and 4 corresponding to the player's choice by calling the helper function `name_to_number()` using `player_choice`.

4. Implement the second part of `rpsls()` that generates the computer's guess and prints out an appropriate message for that guess. In particular, compute a random number `comp_number` between 0 and 4 that corresponds to the computer's guess using the function `sample()`. Then compute the name `comp_choice` corresponding to the computer's number using the function `number_to_name()` and print an appropriate message with the computer's choice to the console.

5. Implement the last part of `rpsls()` that determines and prints out the winner. Specifically, compute the difference between `comp_number` and `player_number` taken modulo five. Then write an `if`/`else if`/`else` statement whose conditions test the various possible values of this difference and then prints an appropriate message concerning the winner.
```{r, echo = FALSE}
rpsls <- function(player_choice) {
    
    name_to_number <- function(name) {
        if(name == "rock") {num <- 0
        } else if(name == "Spock") {num <- 1
        } else if(name == "paper") {num <- 2
        } else if(name == "lizard") {num <- 3
        } else if(name == "scissors") {num <- 4
        } else stop("Invalid name!")
        num
    }
    
    number_to_name <- function(num) {
        if(num == 0) {name <- "rock"
        } else if(num == 1) {name <- "Spock"
        } else if(num == 2) {name <- "paper"
        } else if(num == 3) {name <- "lizard"
        } else if(num == 4) {name <- "scissors"
        } else stop("Invalid number!")
        name
    }
    
    num <- name_to_number(player_choice)
    cat("Player chooses", player_choice, sep = " ")
    cat("\n")
    
    comp_num <- sample(0:4, 1)
    name <- number_to_name(comp_num)
    cat("Computer chooses", name, sep = " ")
    cat("\n")
    
    dif <- num - comp_num
    if(dif == 0) {cat("Player and computer tie!")
    } else if(dif%%5 <= 2) {cat("Player wins!")
    } else if(dif%%5 >= 3) {cat("Computer wins!")
    }
}
```
This will be the only mini-project in the class. Since we have not yet learned enough to allow you to play the game interactively, you will simply call your rpsls function repeatedly in the program with different player choices. You will see that we have provided five such calls at the bottom. Running your program repeatedly should generate different computer guesses and different winners each time. While you are testing, feel free to modify those calls.

The output of running your program should have the following form:
```{r}
rpsls("rock")
```
```{r}
rpsls("Spock")
```
```{r}
rpsls("paper")
```
```{r}
rpsls("lizard")
```
```{r}
rpsls("scissors")
```
Note that, for this mini-project, we will focus only on testing whether your implementation of `rpsls()` works correctly on valid input.
I will assess your mini-project according to the rubric given below. Small deviations from the textual output of our implementation are fine. You should avoid large deviations. 

**Here is a break down of the scoring - **
**15 pts total**

**3 pts** - Program implements the function `rpsls()`, and the helper functions `name_to_number()` and `number_to_name()` with plausible code. Give partial credit of 1 pt for each of the three functions which has plausible code.

**1 pt**  - Running program does not throw an error.

**2 pts** - Program prints `"Player chooses player_choice"` where `player_choice` is a string of the form `"rock"`, `"paper"`, `"scissors"`, `"lizard"` or `"Spock"`. Give 1 pt if program prints out number instead of string.

**2 pts** - Program prints `"Computer chooses comp_choice"` where `comp_choice` is a string of the form `"rock"`, `"paper"`, `"scissors"`, `"lizard"` or `"Spock"`. Give 1 pt if program prints out number instead of string.

**1 pt**  - Computer's guesses vary between five calls to `rpsls()` in each run of the program.

**3 pts** - Program prints either `"Player and computer tie!"`, `"Player wins!"` or `"Computer wins!"` to report outcome. (1 pt for each message.)

**3 pts** - Program chooses correct winner according to RPSLS rules. Please manually examine 5 cases for correctness. If all five cases are correct, award 3 pts; four cases correct award 2 pts; one to three cases correct award 1 pt; no cases correct award 0 pts.

---

*Hope all of you can get great scores!*

*Thank you very much for your support to MSU's R Training Program!*

*Nov., 2014*
